---
title: "Pseudo Absence Bayes Regs"
output: html_document
author: "Shannon Spragg"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Formatting our Pseudo-absence Bayesian Probability of Conflict Regressions:

This document will include the different Bayesian regression models (simplest to most complex) for our WARP pseudo-abs dataframe (1's = all conflict report points , 0's = randomly generated absence points).

We produce three different models to estimate the probability of any wildlife conflict points occurring, in order from simplest to most complex. As we are demonstrating the probability of conflict for any species, we only include predictors that possibly pertain to all species (not bear specific) which are human population density, distance to nearest PA and metro area, total farm count and dominant farm type by CCS region, and a varying intercept for CCS region.

Model 1 (null) : logit(p_conflict) = 1 + a[CCS]
Model 2 (simple) : logit(p_conflict) = a[CCS] + B_1*PopDens 
Model 3 (full) : logit(p_conflict) = a[CCS] + B_1*PopDens + B_2 * Dist2PA + B_3 * Dist2Metro + B_4 * TotalFarms + B_5 * DomFarms

We will use the resulting p(conflict) values to adjust our predictor rasters (multiplying the coefficients by each raster) and combine these rasters into a single raster representing our p(conflict) for general species. These values will then be extracted to points in our p(conflict) model for bears as a predictor.

## Bring in and Scale the Data:

```{r packages, include=FALSE}
library(sf)
library(tidyverse)
library(dplyr)
library(raster)
library(terra)
library(tidyverse)
library(caret)
library(GGally)
library(ggplot2)
library(corrplot)
library(bayesplot)
theme_set(bayesplot::theme_default(base_family = "sans"))
library(rstanarm)
options(mc.cores = 1)
library(loo)
library(projpred)
SEED=14124869
library(sjPlot)
library(nloptr)
library(sjmisc)
library(rsq)
library(tidybayes)
library(pROC)
library(bayestestR)
library(randomForest)
```


```{r data, echo=FALSE}
# Import Data: ------------------------------------------------------------
# Here we have our presence-absence data:
warp.pres.abs <- st_read("/Users/shannonspragg/ONA_GRIZZ/WARP Bears /WARP Cropped - SIP/WARP Final Pres-abs/pres_abs_1k_pa.shp")
head(warp.pres.abs)

# Access this via googledrive: In our ONA-GRIZZ folder
# at the link: https://drive.google.com/drive/u/0/folders/17n64UwIiwhGVCwTQX8uc31ybWJ0YIdtv

# Our bear warp data: ***STILL NEEDS VARINT VARIABLE ADDED***
warp.soi <- st_read("/Users/shannonspragg/ONA_GRIZZ/WARP Bears /WARP SOI - All Reports/warp_final_10k_pa.shp")
```


```{r scale pres-abs variables, echo=FALSE}
# Scale the Variables: ----------------------------------------------------------
# Here we create a function to scale by subtracting the mean and dividing by 2 standard deviations:
scale2sd <-function(variable){(variable - mean(variable, na.rm=TRUE))/(2*sd(variable, na.rm=TRUE))}

b2pa.dist.ps <- scale2sd(warp.pres.abs$ds__PA_)
total.farms.ps <- scale2sd(warp.pres.abs$Ttl_F_C)
b2met.dist.ps <- scale2sd(warp.pres.abs$dstn___)
grizzinc.ps <- scale2sd(warp.pres.abs$GrzzInE)
bhs.ps <- scale2sd(warp.pres.abs$BHSExtr)
biophys.ps <- scale2sd(warp.pres.abs$BphysEx)
pop.dens <- scale2sd(warp.pres.abs$Hmn_Dns)
total.farms <- warp.pres.abs$Ttl_F_C
total.farms.sq <- total.farms * total.farms


bears_presence_ps <- warp.pres.abs$bears # Binomial bears
dom.farms.ps <- warp.pres.abs$Dm_Fr_T # Dominant farm type covariate -- non numeric
dom.farms.ps <- as.factor(warp.pres.abs$Dm_Fr_T) # Making this work as a factor

warp.pres.abs$CCSNAME <- as.factor(warp.pres.abs$CCSNAME)
warp.pres.abs$CCSUID <- as.factor(warp.pres.abs$CCSUID)

CCSUID.ps <- warp.pres.abs$CCSUID
CCSNAME.ps <- warp.pres.abs$CCSNAME

# Add an QUADRATIC term for Farm Count: -----------------------------------
# We want to add a quadratic term to farm count so that we can better interpret it against P(conflict)
total.farms.sq.ps <- total.farms.ps*total.farms.ps

```
We can use the scale function to center our predictors by subtracting the means (center= TRUE) and scaling by dividing by their standard deviation (scale=TRUE). We do this as well as adding a quadratic term for our scaled total farms predictor.

## Producing the Bayes Models:

```{r mini df, echo=FALSE}
# Fit Model with Rstanarm: ------------------------------------------------
# Make a mini data frame with just our predictors (no spatial info):
mini.warp.df.ps <-  data.frame(bears_presence_ps, b2pa.dist.ps, b2met.dist.ps, total.farms.sq.ps, total.farms.ps, dom.farms.ps, CCSNAME.ps, pop.dens)

# Make our outcome to be factor type and create x and y variables:
#mini.warp.df.ps$bears_presence_ps <- factor(mini.warp.df.ps$bears_presence_ps)
str(mini.warp.df.ps)
```
Here we produce a mini data frame that excludes the spatial geometry, but includes all of our critical predictors.

## Fit our Posterior Regressions:
```{r models, echo=FALSE}
# Fitting our Posterior Regression: ---------------------------------------
# tutorial here: https://avehtari.github.io/modelselection/diabetes.html 

# Set our prior:
t_prior <- student_t(df = 7, location = 0, scale = 1.5)
int_prior <- normal(location = 0, scale = NULL, autoscale = FALSE)
# Build our posterior distribution: stan_glm returns the posterior dist for parameters describing the uncertainty related to unknown parameter values

# Start with our Null (Intercept-Only) Model:
post.int.only <- stan_glmer(bears_presence_ps ~ 1 + (1 | CCSNAME.ps), 
                  data = mini.warp.df.ps,
                  family = binomial(link = "logit"), # define our binomial glm
                  prior = t_prior, prior_intercept = int_prior, 
                  iter = 5000,
                  seed = SEED, refresh=0) # we add seed for reproducability

# Look at our simple model:
post.pa.simple <- stan_glmer(bears_presence_ps ~ pop.dens + (1 | CCSNAME.ps), 
                  data = mini.warp.df.ps,
                  family = binomial(link = "logit"), # define our binomial glm
                  prior = t_prior, prior_intercept = int_prior, 
                  iter = 5000,
                  seed = SEED, refresh=0) # we add seed for reproducability

# Build out our Comparison Model (to compare to Global):
  # For this one, we leave out the FarmCount quad term
post.pa.compare <- stan_glmer(bears_presence_ps ~ b2pa.dist.ps + b2met.dist.ps + dom.farms.ps + total.farms.ps + pop.dens + (1 | CCSNAME.ps), 
                            data = mini.warp.df.ps,
                            family = binomial(link = "logit"), # define our binomial glm
                            prior = t_prior, prior_intercept = int_prior,
                            iter = 5000,
                            seed = SEED, refresh=0) # we add seed for reproducability
# If this has a bulk ESS error... need to run chains for longer

# Global Model: including all of our predictors 
post.pa.full <- stan_glmer(bears_presence_ps ~ b2pa.dist.ps + b2met.dist.ps + dom.farms.ps + total.farms.ps + total.farms.sq.ps + pop.dens + (1 | CCSNAME.ps), 
                            data = mini.warp.df.ps,
                            family = binomial(link = "logit"), # define our binomial glm
                            prior = t_prior, prior_intercept = int_prior, QR=TRUE,
                            seed = SEED, refresh=0) # we add seed for reproducability

summary(post.int.onlny)
summary(post.pa.simple)
summary(post.pa.compare)
summary(post.pa.full)

# Save an object to a file
saveRDS(post.pa.full, file = "post_pa_full.rds")
post.pa.full <- readRDS(file = "post_pa_full.rds")


plot_model(post.pa.full, sort.est = TRUE)

# Labeled Effect Plot:
# Notes: axis labels should be in order from bottom to top. 
# To see the values of the effect size and p-value, set show.values and show.p= TRUE
post.pa.full.effects.plot <- sjPlot::plot_model(post.pa.full, 
                                         axis.labels=c("Population Density", "Total Farm Count ^2" ,"Total Farm Count" ,"Vegetable & Melon Farming" , "Other Crop Farming (tobacco, peanut, sugar-cane, hay, herbs & spices) ", "Other Animal Production (bees & honey, equine, fur-bearers)" , "Fruit & Tree Nut Farming" , "Cattle Ranching & Farming" , "Distance to Metro Area (km)",
                                                        "Distance to Protected Area (km)"),
                                         show.values=TRUE, show.p=FALSE,
                                         title="Effects of Social & Environmental Variables on General Conflict")

```
Here we set our initial priors to students t with 7 degrees of freedom, and a scale of 2.5 which is a reasonable default fir prior when coefficients should be close to zero but have some chance of being large. We build our three models using stan_glm to return our posterior distribution for the specified model parameters. Our first model, logit(p_conflict) = B_1*PopDens , has a 0.8 coefficient/mean for population density. Model 2, logit(p_conflict) = a[CCS] + B_1 * PopDens includes a varying intercept for CCS region and a coefficient/mean of -2.3 for population density. The full model, logit(p_conflict) = a[CCS] + B_1*PopDens + B_2 * Dist2PA + B_3 * Dist2Metro + B_4 * TotalFarms + B_5 * DomFarms shows a -3.3 coefficient for Dist2PA, a -1.4 for Dist2Metro , a -0.3 for Cattle Ranching & Farming (Domfarms), 1.1 Fruit and tree nut farming (Domfarms), 1.6 for Other animal production (Domfarms), 1.6 for Other crop farming (Domfarms), 0.2 for Vegetable & Meelon farming, -0.3 for total farms , 0.5 for total farsms squared, and 0.7 for population density.


## Find the Area Under the Curve for our Posterior Distributions:

```{r roc plot, echo=FALSE}
# Plot ROC for the Simple Posterior:
par(pty="s") # sets our graph to square
roc(bears_presence_ps, post.pa.full$fitted.values, plot=TRUE, legacy.axes=TRUE, percent=TRUE ,
    xlab= "False Positive Percentage", ylab= "True Positive Percentage",
    col="#377eb8", lwd=4, print.auc=TRUE) # this gives us the ROC curve , in 3544 controls (bears 0) < 2062 cases (bears 1), Area under curve = 0.82

# Add ROC curve for our full pseudo-abs model:
plot.roc(bears_presence_ps, post.pa.simple$fitted.values, percent=TRUE, col='#4daf4a', lwd=4, print.auc=TRUE, add=TRUE, print.auc.y=60)

plot.roc(bears_presence_ps, post.pa.simplest$fitted.values, percent=TRUE, col='red', lwd=4, print.auc=TRUE, add=TRUE, print.auc.y=40)

legend("bottomright", legend=c("Full Pseudo-abs Regression", "Simple Pseudo-Abs Regression", "Simplest Pseudo-abs Regression"),
       col=c("#377eb8", "#4daf4a", "red"), lwd = 4)
```
Comparing the simple pseudo-absence model with the full model in a ROC plot shows that the full model has a 82% discrimination. This indicates that the model predictions are correct 82% of the time, slightly better than the simple model at 79% and the simplest model at 67%.


## Leave One Out Cross Validation:

```{r LOO, echo=FALSE}
# Leave-one-out Cross_validation: -----------------------------------------
# Run a Leave-One-Out (LOO):
# Loo package implements fast Pareto smoothed leave-one-out-cross-val (PSIS-LOO) to compute expected log predictive density:
(loo.simplest <- loo(post.pa.simplest, save_psis = TRUE))
# Above we see that PSIS-LOO result is reliable as all Pareto k estimates are small (k< 0.5) Vehtari, Gelman and Gabry (2017a).
(loo.simple <- loo(post.pa.simple, save_psis = TRUE))

# Compare the LOO values for full model vs the one with quad term:
(loo.pa.comp <- loo(post.pa.compare, save_psis = TRUE))
(loo.pa.full <- loo(post.pa.full, save_psis = TRUE))


plot(loo.pa.full, label_points = TRUE)
loo.pa.full # get the summary of our test

############## Comparison to Baseline Model: -------------------------------------------

# Compute our baseline result without covariates:
post0.ps <- update(post.int.only, formula = bears_presence_ps ~ 1 + (1 | CCSNAME.ps), QR = FALSE, refresh=0)

# Compare to our baseline:
(loo.0 <- loo(post0.ps)) # computing the PSIS-LOO for our baseline model

loo.comparison <- loo_compare(loo.0, loo.pa.comp, loo.pa.full) # this high negative value for post0 shows us the covariates contain clearly useful information for predictions
```
We conduct a leave-one-out cross validation for our three models and then compare them to the zero posterior. Above, we see that the full model and simple model's PSIS-LOO result is reliable as all Pareto k estimates are small (k< 0.5) and the Monte Carlo SE is 0.1 (Vehtari, Gelman and Gabry 2017a). The simplest model is also reliable as it has a Monte Carlo SE of 0.0 and all Pareto k estimates are small (k< 0.5). Comparing these LOO values to our baseline, we see that the theoretical expected log point wise predictive density (elpd_loo) is lowest for our full model (still lower than the compare model) and highest for our baseline posterior, indicating that the increased covariates in our models contain clearly useful information for predictions.

## K-Fold Cross Validation:
```{r K fold cross validate}
# K Fold Cross Validation: -----------------------------------------
# Setting up a K - fold cross validation for our general model: 

# 4-fold cross-validation
# (if possible also specify the 'cores' argument to use multiple cores) 
(kfold1.ps <- rstanarm::kfold(post.pa.full, K = 10, cores = getOption("mc.cores", 1)))

# Try a stratified k-fold, stratifying on the CCSID variable:
cv10folds.ccs <- kfold_split_stratified(K=10, x=mini.warp.df.ps$CCSNAME.ps)

cv10folds.farms<- kfold_split_stratified(K=10, x=mini.warp.df.ps$dom.farms.ps)

# What about with dom farms:
cv6folds <- kfold_split_stratified(K=6, x=mini.warp.df.ps$dom.farms.ps)


# Now run K fold with stratified variable:
kfold.10.ps <-kfold(post.pa.full, K=10, cores = getOption("mc.cores", 1))

kfold.10.ps <- rstanarm::kfold(post.pa.full, K=10, folds = cv10folds.ccs)
```


## Plotting Our Mixed Effects:
```{r mixed efffects, echo=FALSE}
# Basic Mixed Effect Plot:
sjPlot::plot_model(post.pa.full)

# Labeled Effect Plot:
# Notes: axis labels should be in order from bottom to top. 
# To see the values of the effect size and p-value, set show.values and show.p= TRUE
post1.effects.plot <- sjPlot::plot_model(post.pa.full, 
                   axis.labels=c("CS Biophysical (HII + topo ruggedness)","Bear Habitat Suitability", "Grizz Increase", "Total Farm Count ^2" ,"Total Farm Count" ,"Vegetable & Melon Farming" ,
                                 "Other Crop Farming (tobacco, peanut, sugar-cane, hay, herbs & spices) ", "Other Animal Production (bees & honey, equine, fur-bearers)" , "Fruit & Tree Nut Farming" , "Cattle Ranching & Farming" ,
                                   "Distance to Metro Area (km)" , "Distance to Protected Area (km)"),
                   show.values=TRUE, show.p=FALSE,
                   title="Effects of Social & Environmental Variables on Bear Conflict")

##### Model Table of Effect Size:
sjPlot::tab_model(post.pa.full)

# Formatted Table (with labels):
# Notes: predictor labels (pred.labels) should be listed from top to bottom; dv.labels= the name of the response variable that will be at the top of the table.

post1.effects.tab <- sjPlot::tab_model(post1, 
                  show.re.var= TRUE, show.se = TRUE , show.p = TRUE , show.r2 = TRUE, show.aic = TRUE , 
                  pred.labels =c("(Intercept)" , "Distance to Protected Area (km)", "Distance to Metro Area (km)", "Cattle Ranching & Farming" , "Fruit & Tree Nut Farming" ,"Other Animal Production (bees & honey, equine, fur-bearers)" ,
                                 "Other Crop Farming (tobacco, peanut, sugar-cane, hay, herbs & spices) ", "Vegetable & Melon Farming" , "Total Farm Count" , "Total Farm Count ^2" , "Grizz Increase", "Bear Habitat Suitability", "CS Biophysical (HII + topo ruggedness)"),
                                 dv.labels= "Effects of Social & Environmental Variables on Bear Conflict")

```

## Create our P(General Conflict) Raster:

Here we use the coefficients resulting from the above full regression to preform raster math (coeff_1 * predictor raster + coeff_2 * predictor raster + ...) to create one condensed raster representing the probability of general conflict.

Then, we extract the values of this raster to our original warp conflict report data frame (1's = bears, 0's = other species reports), to use the p(general conlfict) as a predictor in the second Bayes model of bear conflict.

# Bring in Rasters:
```{r bring in data 2, include=FALSE}
# Here we bring in all of our predictor rasters for the SOI region:
# link to data here:   https://drive.google.com/drive/u/0/folders/1T60Al9vHOF-E7ftKzvzN2CMUyF1agC-l

# Dominant Farm Type by CCS Region:
dom.farms.rast <- terra::rast("/Users/shannonspragg/ONA_GRIZZ/Predictor Rasters/dom_farm_type_raster.tif")

beef.cattle.rast <- rast("/Users/shannonspragg/ONA_GRIZZ/Predictor Rasters/beef_cattle_raster.tif")
cattle.ranching.rast <- rast("/Users/shannonspragg/ONA_GRIZZ/Predictor Rasters/cattle_ranching_raster.tif")
other.animal.rast <- rast("/Users/shannonspragg/ONA_GRIZZ/Predictor Rasters/other_animal_prod_raster.tif")
fruit.tree.nut.rast <- rast("/Users/shannonspragg/ONA_GRIZZ/Predictor Rasters/fruit_treenut_raster.tif")
other.crop.rast <- rast("/Users/shannonspragg/ONA_GRIZZ/Predictor Rasters/other_crop_prod_raster.tif")
greenhs.rast <- rast("/Users/shannonspragg/ONA_GRIZZ/Predictor Rasters/greenhouse_crop_raster.tif")
veg.mel.rast <- rast("/Users/shannonspragg/ONA_GRIZZ/Predictor Rasters/veg_melon_raster.tif")

# Total Farm Count by CCS Region:
tot.farms.rast <- terra::rast("/Users/shannonspragg/ONA_GRIZZ/Predictor Rasters/total_farm_count_raster.tif" )

# Total Farm Count Squared:
tot.farms.sq.rast <- tot.farms.rast * tot.farms.rast # I am not sure how to do this one...

# Distance to Neartest Protected Area (km):
dist2pa.rast.general.1k <- terra::rast("/Users/shannonspragg/ONA_GRIZZ/Predictor Rasters/1k_ha_dist2pa_raster.tif" )

# Distance to Nearest Metro Area (km):
dist2met.rast <- terra::rast("/Users/shannonspragg/ONA_GRIZZ/Predictor Rasters/dist2metro_raster.tif" )

# Human Pop Density (by sq km):
hm.dens.rast <- terra::rast("/Users/shannonspragg/ONA_GRIZZ/CAN Spatial Data/Human Pop Density/human_dens_SOI_10km.tif") # SOI Region 10km

# CCS Region ID:
ccs.varint.rast <- terra::rast("/Users/shannonspragg/ONA_GRIZZ/Predictor Rasters/CCS_varint_raster.tif" )
names(ccs.varint.rast)[names(ccs.varint.rast) == "PostMean"] <- "CCS Varying Intercept Mean"
```


```{r scale our variables}
# Scale the Rasters:
# Here we create a function to scale by subtracting the mean and dividing by 2 standard deviations:
scale2sd.raster <-function(variable){(variable - global(variable, "mean", na.rm=TRUE)[,1])/(2*global(variable, "sd", na.rm=TRUE)[,1])}
dist2metro.rast.sc <- scale2sd.raster(dist2met.rast) 
dist2pa.rast.sc <- scale2sd.raster(dist2pa.rast.general.1k)
tot.farms.rast.sc <- scale2sd.raster(tot.farms.rast)
tot.farms.sq.rast.sc <- scale2sd.raster(tot.farms.sq.rast)
hm.dens.rast.sc <- scale2sd.raster(hm.dens.rast)


# We can also do this Step by Step:

# Distance to PA:
d2pa.mean <- mean(warp.pres.abs$ds__PA_)
d2pa.sub.mean <- dist2pa.rast.general.1k - d2pa.mean
d2pa.sd <- sd(warp.pres.abs$ds__PA_)
dist2pa.rast.sc <- d2pa.sub.mean / ( 2 * d2pa.sd)

# Distance to Metro
d2met.mean <- mean(warp.pres.abs$dstn___)
d2met.sub.mean <- dist2met.rast - d2met.mean
d2met.sd <- sd(warp.pres.abs$dstn___)
dist2metro.rast.sc <- d2met.sub.mean / ( 2 * d2met.sd)

# Total Farm Count:
ttl.farm.mean <- mean(warp.pres.abs$Ttl_F_C)
ttl.f.sub.mean <- tot.farms.rast - ttl.farm.mean
ttl.f.sd <- sd(warp.pres.abs$Ttl_F_C)
tot.farms.rast.sc <- ttl.f.sub.mean / ( 2 * ttl.f.sd)

# Total Farms Sq:
ttl.farm.sq.mean <- mean(total.farms.sq)
ttl.f.sq.sub.mean <- tot.farms.sq.rast - ttl.farm.sq.mean
ttl.f.sq.sd <- sd(total.farms.sq)
tot.farms.sq.rast.sc <- ttl.f.sq.sub.mean / ( 2 * ttl.f.sq.sd)

# Human Density:
pop.dens.mean <- mean(warp.pres.abs$Hmn_Dns)
pop.sub.mean <- hm.dens.rast - pop.dens.mean
pop.dens.sd <- sd(warp.pres.abs$Hmn_Dns)
hm.dens.rast.sc <- pop.sub.mean / ( 2 * pop.dens.sd)

```


```{r raster math, include=TRUE}
# Make sure extents match:
ext(dist2pa.rast.general.1k) == ext(dist2met.rast) # TRUE
ext(dist2met.rast) == ext(tot.farms.rast) #TRUE
ext(tot.farms.rast) == ext(hm.dens.rast) #TRUE

# View our Full Model Coefficients:
summary(post.pa.full)


# Stack these spatrasters:
conf.rast.stack <- c(dist2pa.rast.sc, dist2metro.rast.sc, tot.farms.rast.sc, tot.farms.sq.rast.sc, hm.dens.rast.sc, ccs.varint.rast, cattle.ranching.rast, fruit.tree.nut.rast, other.animal.rast, other.crop.rast, veg.mel.rast)
plot(conf.rast.stack) # plot these all to check

# It looks like veg.melon raster has all 0 values, so isn't working

# Create P(all conflict) raster with our regression coefficients and rasters:
    # Prob_conf_rast = Int.val + CCS + B_1est * PopDensâ€¦
conflict_rast <- -3.2624640 + ccs.varint.rast + (-1.3887130 * dist2pa.rast.sc) + (-1.2986664 * dist2metro.rast.sc) + (-0.2535196 * tot.farms.rast.sc) + (0.4583006 * tot.farms.sq.rast.sc) + (0.7262155 * hm.dens.rast.sc) + (-0.2987515 * cattle.ranching.rast) + (1.1384551 * fruit.tree.nut.rast) + (1.5483847 * other.animal.rast) + (1.6437851 * other.crop.rast) + (0.2613143 * veg.mel.rast)

# Convert the Raster to the Probability Scale:
p_conf_rast <- app(conflict_rast, fun=plogis)

plot(p_conf_rast)
```
We use raster math calculations to apply the regression coefficients to each corresponding raster and add these together to produce our probability of general wildlife conflict raster.

```{r write raster}
# Save our P(General Conflict) Raster:
terra::writeRaster(p_conf_rast, "/Users/shannonspragg/ONA_GRIZZ/Predictor Rasters/prob_general_conf.tif")

```






